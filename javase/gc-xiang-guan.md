# GC相关

## 1、类加载器

### 1.1 概念

![](../.gitbook/assets/image%20%2851%29.png)

### 1.2 分类

1. BootStrap  启动  使用C++来实现，不继承ClassLoader
2. Extension  扩展  
3. App ClassLoader
4. 自定义类加载器

### 1.3 双亲委托模型

先委托给父加载器来加载，只有父加载器无法加载才

### 1.4 类加载的过程

![](../.gitbook/assets/image%20%286%29.png)

1. 静态绑定
2. 动态绑定

![](../.gitbook/assets/image%20%2835%29.png)

![](../.gitbook/assets/image%20%2844%29.png)

## 2、java堆栈

### 2.1 java内存分配策略

![](../.gitbook/assets/image%20%2815%29.png)

### 2.2 堆栈内存区别

1、从内存分配角度：

![](../.gitbook/assets/image%20%2828%29.png)

### 2.3 gc机制

#### 引用计数法

存在循环引用的问题

#### 根可达性

目前JVM基本都采用这种，从GC Roots作为起点开始搜索，那么整个连通图中的对象便是活对象

**可作为gcRoot的对象**：

* Java栈中的引用的对象
* 本地方法栈中JNI引用的对象
* 方法区中运行时常量池引用的对象
* 方法区中静态属性引用的对象
* 运行中的线程
* 由引导类加载器加载的对象
* GC控制的对象

#### gc算法

分代回收，新生代使用复制算法，老年代使用标记-清除算法或标记-整理算法来进行回收

1. 复制：将内存分为两块区域，每次使用其中一块，当这块内存用完了，将还存活的对象复制到另一块区域，然后对该块进行内存回收
2. 标记-清除：标记需要回收的对象空间，并将标记的对象空间回收 缺点：会产生大量不连续的内存碎片，会导致分配大对象时无法找到足够连续的内存而触发另一次的垃圾回收动作。
3. 标记-整理：标记需要回收的对象之后，会将所有存活的对象空间挪到一起，然后再执行清理。 有效的预防了可能产生过多内存碎片的问题。

### 2.4 内存泄漏

![](../.gitbook/assets/image%20%2825%29.png)

